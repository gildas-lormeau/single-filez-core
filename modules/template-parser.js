/*
 * Copyright 2010-2022 Gildas Lormeau
 * contact : gildas.lormeau <at> gmail.com
 * 
 * This file is part of SingleFile.
 *
 *   The code in this file is free software: you can redistribute it and/or 
 *   modify it under the terms of the GNU Affero General Public License 
 *   (GNU AGPL) as published by the Free Software Foundation, either version 3
 *   of the License, or (at your option) any later version.
 * 
 *   The code in this file is distributed in the hope that it will be useful, 
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of 
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero 
 *   General Public License for more details.
 *
 *   As additional permission under GNU AGPL version 3 section 7, you may 
 *   distribute UNMODIFIED VERSIONS OF THIS file without the copy of the GNU 
 *   AGPL normally required by section 4, provided you include this license 
 *   notice and a URL through which recipients can access the Corresponding 
 *   Source.
 */

/* eslint-disable no-control-regex */

/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */

/* Modified manually by Gildas Lormeau in order to support async/await callbacks */

export {
	peg$SyntaxError as SyntaxError,
	peg$parse as parse
};

function peg$subclass(child, parent) {
	function ctor() { this.constructor = child; }
	ctor.prototype = parent.prototype;
	child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
	this.message = message;
	this.expected = expected;
	this.found = found;
	this.location = location;
	this.name = "SyntaxError";

	if (typeof Error.captureStackTrace === "function") {
		Error.captureStackTrace(this, peg$SyntaxError);
	}
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function (expected, found) {
	var DESCRIBE_EXPECTATION_FNS = {
		literal: function (expectation) {
			return "\"" + literalEscape(expectation.text) + "\"";
		},

		"class": function (expectation) {
			var escapedParts = "",
				i;

			for (i = 0; i < expectation.parts.length; i++) {
				escapedParts += expectation.parts[i] instanceof Array
					? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
					: classEscape(expectation.parts[i]);
			}

			return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
		},

		any: function () {
			return "any character";
		},

		end: function () {
			return "end of input";
		},

		other: function (expectation) {
			return expectation.description;
		}
	};

	function hex(ch) {
		return ch.charCodeAt(0).toString(16).toUpperCase();
	}

	function literalEscape(s) {
		return s
			.replace(/\\/g, "\\\\")
			.replace(/"/g, "\\\"")
			.replace(/\0/g, "\\0")
			.replace(/\t/g, "\\t")
			.replace(/\n/g, "\\n")
			.replace(/\r/g, "\\r")
			.replace(/[\x00-\x0F]/g, function (ch) { return "\\x0" + hex(ch); })
			.replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return "\\x" + hex(ch); });
	}

	function classEscape(s) {
		return s
			.replace(/\\/g, "\\\\")
			.replace(/\]/g, "\\]")
			.replace(/\^/g, "\\^")
			.replace(/-/g, "\\-")
			.replace(/\0/g, "\\0")
			.replace(/\t/g, "\\t")
			.replace(/\n/g, "\\n")
			.replace(/\r/g, "\\r")
			.replace(/[\x00-\x0F]/g, function (ch) { return "\\x0" + hex(ch); })
			.replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return "\\x" + hex(ch); });
	}

	function describeExpectation(expectation) {
		return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
	}

	function describeExpected(expected) {
		var descriptions = new Array(expected.length),
			i, j;

		for (i = 0; i < expected.length; i++) {
			descriptions[i] = describeExpectation(expected[i]);
		}

		descriptions.sort();

		if (descriptions.length > 0) {
			for (i = 1, j = 1; i < descriptions.length; i++) {
				if (descriptions[i - 1] !== descriptions[i]) {
					descriptions[j] = descriptions[i];
					j++;
				}
			}
			descriptions.length = j;
		}

		switch (descriptions.length) {
			case 1:
				return descriptions[0];

			case 2:
				return descriptions[0] + " or " + descriptions[1];

			default:
				return descriptions.slice(0, -1).join(", ")
					+ ", or "
					+ descriptions[descriptions.length - 1];
		}
	}

	function describeFound(found) {
		return found ? "\"" + literalEscape(found) + "\"" : "end of input";
	}

	return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

async function peg$parse(input, options) {
	options = options !== void 0 ? options : {};

	var peg$FAILED = {},

		peg$startRuleFunctions = { start: peg$parsestart },
		peg$startRuleFunction = peg$parsestart,

		peg$c0 = function (expression) { return expression.join(""); },
		peg$c1 = "|",
		peg$c2 = peg$literalExpectation("|", false),
		peg$c3 = function (value) { return value; },
		peg$c4 = "%",
		peg$c5 = peg$literalExpectation("%", false),
		peg$c6 = "<",
		peg$c7 = peg$literalExpectation("<", false),
		peg$c8 = ">",
		peg$c9 = peg$literalExpectation(">", false),
		peg$c10 = function (name, args, length) { return options.callFunction(name, args, length); },
		peg$c11 = "{",
		peg$c12 = peg$literalExpectation("{", false),
		peg$c13 = "}",
		peg$c14 = peg$literalExpectation("}", false),
		peg$c15 = function (name, length) { return options.getVariableValue(name, length); },
		peg$c16 = "[",
		peg$c17 = peg$literalExpectation("[", false),
		peg$c18 = "]",
		peg$c19 = peg$literalExpectation("]", false),
		peg$c20 = function (length, unit) { return { length, unit }; },
		peg$c21 = "ch",
		peg$c22 = peg$literalExpectation("ch", false),
		peg$c23 = /^[a-z0-9-]/,
		peg$c24 = peg$classExpectation([["a", "z"], ["0", "9"], "-"], false, false),
		peg$c25 = function () { return text(); },
		peg$c26 = /^[0-9]/,
		peg$c27 = peg$classExpectation([["0", "9"]], false, false),
		peg$c28 = function () { return Number(text()); },
		peg$c29 = "\\\\%",
		peg$c30 = peg$literalExpectation("\\\\%", false),
		peg$c31 = "\\\\{",
		peg$c32 = peg$literalExpectation("\\\\{", false),
		peg$c33 = "\\\\|",
		peg$c34 = peg$literalExpectation("\\\\|", false),
		peg$c35 = "\\\\>",
		peg$c36 = peg$literalExpectation("\\\\>", false),
		peg$c37 = peg$anyExpectation(),

		peg$currPos = 0,
		peg$savedPos = 0,
		peg$posDetailsCache = [{ line: 1, column: 1 }],
		peg$maxFailPos = 0,
		peg$maxFailExpected = [],
		peg$silentFails = 0,

		peg$result;

	if ("startRule" in options) {
		if (!(options.startRule in peg$startRuleFunctions)) {
			throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
		}

		peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	}

	function text() {
		return input.substring(peg$savedPos, peg$currPos);
	}

	function peg$literalExpectation(text, ignoreCase) {
		return { type: "literal", text: text, ignoreCase: ignoreCase };
	}

	function peg$classExpectation(parts, inverted, ignoreCase) {
		return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
	}

	function peg$anyExpectation() {
		return { type: "any" };
	}

	function peg$endExpectation() {
		return { type: "end" };
	}

	function peg$computePosDetails(pos) {
		var details = peg$posDetailsCache[pos], p;

		if (details) {
			return details;
		} else {
			p = pos - 1;
			while (!peg$posDetailsCache[p]) {
				p--;
			}

			details = peg$posDetailsCache[p];
			details = {
				line: details.line,
				column: details.column
			};

			while (p < pos) {
				if (input.charCodeAt(p) === 10) {
					details.line++;
					details.column = 1;
				} else {
					details.column++;
				}

				p++;
			}

			peg$posDetailsCache[pos] = details;
			return details;
		}
	}

	function peg$computeLocation(startPos, endPos) {
		var startPosDetails = peg$computePosDetails(startPos),
			endPosDetails = peg$computePosDetails(endPos);

		return {
			start: {
				offset: startPos,
				line: startPosDetails.line,
				column: startPosDetails.column
			},
			end: {
				offset: endPos,
				line: endPosDetails.line,
				column: endPosDetails.column
			}
		};
	}

	function peg$fail(expected) {
		if (peg$currPos < peg$maxFailPos) { return; }

		if (peg$currPos > peg$maxFailPos) {
			peg$maxFailPos = peg$currPos;
			peg$maxFailExpected = [];
		}

		peg$maxFailExpected.push(expected);
	}

	function peg$buildStructuredError(expected, found, location) {
		return new peg$SyntaxError(
			peg$SyntaxError.buildMessage(expected, found),
			expected,
			found,
			location
		);
	}

	async function peg$parsestart() {
		var s0;

		s0 = await peg$parseexpression();

		return s0;
	}

	async function peg$parseexpression() {
		var s0, s1, s2;

		s0 = peg$currPos;
		s1 = [];
		s2 = await peg$parsestatement();
		while (s2 !== peg$FAILED) {
			s1.push(s2);
			s2 = await peg$parsestatement();
		}
		if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c0(s1);
		}
		s0 = s1;

		return s0;
	}

	async function peg$parsestatement() {
		var s0;

		s0 = await peg$parsefunctionCall();
		if (s0 === peg$FAILED) {
			s0 = await peg$parsevariable();
			if (s0 === peg$FAILED) {
				s0 = peg$parsetext();
			}
		}

		return s0;
	}

	async function peg$parsearg() {
		var s0, s1, s2;

		s0 = peg$currPos;
		if (input.charCodeAt(peg$currPos) === 124) {
			s1 = peg$c1;
			peg$currPos++;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c2); }
		}
		if (s1 !== peg$FAILED) {
			s2 = await peg$parseexpression();
			if (s2 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c3(s2);
				s0 = s1;
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		return s0;
	}

	async function peg$parseoptionalArgs() {
		var s0, s1;

		s0 = [];
		s1 = await peg$parsearg();
		if (s1 !== peg$FAILED) {
			while (s1 !== peg$FAILED) {
				s0.push(s1);
				s1 = await peg$parsearg();
			}
		} else {
			s0 = peg$FAILED;
		}

		return s0;
	}

	async function peg$parseargs() {
		var s0, s1, s2;

		s0 = peg$currPos;
		s1 = await peg$parseexpression();
		if (s1 !== peg$FAILED) {
			s2 = await peg$parseoptionalArgs();
			if (s2 === peg$FAILED) {
				s2 = null;
			}
			if (s2 !== peg$FAILED) {
				s1 = [s1, s2];
				s0 = s1;
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		return s0;
	}

	async function peg$parsefunctionCall() {
		var s0, s1, s2, s3, s4, s5, s6;

		s0 = peg$currPos;
		if (input.charCodeAt(peg$currPos) === 37) {
			s1 = peg$c4;
			peg$currPos++;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c5); }
		}
		if (s1 !== peg$FAILED) {
			s2 = peg$parseidentifier();
			if (s2 !== peg$FAILED) {
				if (input.charCodeAt(peg$currPos) === 60) {
					s3 = peg$c6;
					peg$currPos++;
				} else {
					s3 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c7); }
				}
				if (s3 !== peg$FAILED) {
					s4 = await peg$parseargs();
					if (s4 !== peg$FAILED) {
						if (input.charCodeAt(peg$currPos) === 62) {
							s5 = peg$c8;
							peg$currPos++;
						} else {
							s5 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c9); }
						}
						if (s5 !== peg$FAILED) {
							s6 = peg$parseresultLength();
							if (s6 === peg$FAILED) {
								s6 = null;
							}
							if (s6 !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = await peg$c10(s2, s4, s6);
								s0 = s1;
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		return s0;
	}

	async function peg$parsevariable() {
		var s0, s1, s2, s3, s4;

		s0 = peg$currPos;
		if (input.charCodeAt(peg$currPos) === 123) {
			s1 = peg$c11;
			peg$currPos++;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c12); }
		}
		if (s1 !== peg$FAILED) {
			s2 = peg$parseidentifier();
			if (s2 !== peg$FAILED) {
				if (input.charCodeAt(peg$currPos) === 125) {
					s3 = peg$c13;
					peg$currPos++;
				} else {
					s3 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c14); }
				}
				if (s3 !== peg$FAILED) {
					s4 = peg$parseresultLength();
					if (s4 === peg$FAILED) {
						s4 = null;
					}
					if (s4 !== peg$FAILED) {
						peg$savedPos = s0;
						s1 = await peg$c15(s2, s4);
						s0 = s1;
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		return s0;
	}

	function peg$parseresultLength() {
		var s0, s1, s2, s3, s4;

		s0 = peg$currPos;
		if (input.charCodeAt(peg$currPos) === 91) {
			s1 = peg$c16;
			peg$currPos++;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c17); }
		}
		if (s1 !== peg$FAILED) {
			s2 = peg$parsenumber();
			if (s2 !== peg$FAILED) {
				s3 = peg$parselengthUnit();
				if (s3 !== peg$FAILED) {
					if (input.charCodeAt(peg$currPos) === 93) {
						s4 = peg$c18;
						peg$currPos++;
					} else {
						s4 = peg$FAILED;
						if (peg$silentFails === 0) { peg$fail(peg$c19); }
					}
					if (s4 !== peg$FAILED) {
						peg$savedPos = s0;
						s1 = peg$c20(s2, s3);
						s0 = s1;
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		return s0;
	}

	function peg$parselengthUnit() {
		var s0;

		if (input.substr(peg$currPos, 2) === peg$c21) {
			s0 = peg$c21;
			peg$currPos += 2;
		} else {
			s0 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c22); }
		}
		if (s0 === peg$FAILED) {
			s0 = null;
		}

		return s0;
	}

	function peg$parseidentifier() {
		var s0, s1, s2;

		s0 = peg$currPos;
		s1 = [];
		if (peg$c23.test(input.charAt(peg$currPos))) {
			s2 = input.charAt(peg$currPos);
			peg$currPos++;
		} else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c24); }
		}
		if (s2 !== peg$FAILED) {
			while (s2 !== peg$FAILED) {
				s1.push(s2);
				if (peg$c23.test(input.charAt(peg$currPos))) {
					s2 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s2 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c24); }
				}
			}
		} else {
			s1 = peg$FAILED;
		}
		if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c25();
		}
		s0 = s1;

		return s0;
	}

	function peg$parsenumber() {
		var s0, s1, s2;

		s0 = peg$currPos;
		s1 = [];
		if (peg$c26.test(input.charAt(peg$currPos))) {
			s2 = input.charAt(peg$currPos);
			peg$currPos++;
		} else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c27); }
		}
		if (s2 !== peg$FAILED) {
			while (s2 !== peg$FAILED) {
				s1.push(s2);
				if (peg$c26.test(input.charAt(peg$currPos))) {
					s2 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s2 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c27); }
				}
			}
		} else {
			s1 = peg$FAILED;
		}
		if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c28();
		}
		s0 = s1;

		return s0;
	}

	function peg$parsetext() {
		var s0, s1, s2;

		s0 = peg$currPos;
		s1 = [];
		s2 = peg$parsechar();
		if (s2 !== peg$FAILED) {
			while (s2 !== peg$FAILED) {
				s1.push(s2);
				s2 = peg$parsechar();
			}
		} else {
			s1 = peg$FAILED;
		}
		if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c25();
		}
		s0 = s1;

		return s0;
	}

	function peg$parsechar() {
		var s0, s1, s2, s3, s4, s5;

		s0 = peg$currPos;
		s1 = peg$currPos;
		peg$silentFails++;
		if (input.charCodeAt(peg$currPos) === 37) {
			s2 = peg$c4;
			peg$currPos++;
		} else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c5); }
		}
		peg$silentFails--;
		if (s2 === peg$FAILED) {
			s1 = void 0;
		} else {
			peg$currPos = s1;
			s1 = peg$FAILED;
		}
		if (s1 !== peg$FAILED) {
			s2 = peg$currPos;
			peg$silentFails++;
			if (input.charCodeAt(peg$currPos) === 123) {
				s3 = peg$c11;
				peg$currPos++;
			} else {
				s3 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c12); }
			}
			peg$silentFails--;
			if (s3 === peg$FAILED) {
				s2 = void 0;
			} else {
				peg$currPos = s2;
				s2 = peg$FAILED;
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$currPos;
				peg$silentFails++;
				if (input.charCodeAt(peg$currPos) === 124) {
					s4 = peg$c1;
					peg$currPos++;
				} else {
					s4 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c2); }
				}
				peg$silentFails--;
				if (s4 === peg$FAILED) {
					s3 = void 0;
				} else {
					peg$currPos = s3;
					s3 = peg$FAILED;
				}
				if (s3 !== peg$FAILED) {
					s4 = peg$currPos;
					peg$silentFails++;
					if (input.charCodeAt(peg$currPos) === 62) {
						s5 = peg$c8;
						peg$currPos++;
					} else {
						s5 = peg$FAILED;
						if (peg$silentFails === 0) { peg$fail(peg$c9); }
					}
					peg$silentFails--;
					if (s5 === peg$FAILED) {
						s4 = void 0;
					} else {
						peg$currPos = s4;
						s4 = peg$FAILED;
					}
					if (s4 !== peg$FAILED) {
						s5 = peg$parseescapedChar();
						if (s5 !== peg$FAILED) {
							s1 = [s1, s2, s3, s4, s5];
							s0 = s1;
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		return s0;
	}

	function peg$parseescapedChar() {
		var s0;

		if (input.substr(peg$currPos, 3) === peg$c29) {
			s0 = peg$c29;
			peg$currPos += 3;
		} else {
			s0 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c30); }
		}
		if (s0 === peg$FAILED) {
			if (input.substr(peg$currPos, 3) === peg$c31) {
				s0 = peg$c31;
				peg$currPos += 3;
			} else {
				s0 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c32); }
			}
			if (s0 === peg$FAILED) {
				if (input.substr(peg$currPos, 3) === peg$c33) {
					s0 = peg$c33;
					peg$currPos += 3;
				} else {
					s0 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c34); }
				}
				if (s0 === peg$FAILED) {
					if (input.substr(peg$currPos, 3) === peg$c35) {
						s0 = peg$c35;
						peg$currPos += 3;
					} else {
						s0 = peg$FAILED;
						if (peg$silentFails === 0) { peg$fail(peg$c36); }
					}
					if (s0 === peg$FAILED) {
						if (input.length > peg$currPos) {
							s0 = input.charAt(peg$currPos);
							peg$currPos++;
						} else {
							s0 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c37); }
						}
					}
				}
			}
		}

		return s0;
	}

	peg$result = await peg$startRuleFunction();

	if (peg$result !== peg$FAILED && peg$currPos === input.length) {
		return peg$result;
	} else {
		if (peg$result !== peg$FAILED && peg$currPos < input.length) {
			peg$fail(peg$endExpectation());
		}

		throw peg$buildStructuredError(
			peg$maxFailExpected,
			peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
			peg$maxFailPos < input.length
				? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
				: peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
		);
	}
}